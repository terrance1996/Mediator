// <auto-generated>
//     Generated by the Mediator source generator.
// </auto-generated>

using Microsoft.Extensions.DependencyInjection;
using System.Linq;

namespace {{ MediatorNamespace }}
{
    /// <summary>
    /// DI extensions for Mediator.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "1.0.0.0")]
    public static class DependencyInjectionExtensions
    {
        /// <summary>
        /// Adds the Mediator implementation and handlers of your application.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static IServiceCollection AddMediator(this IServiceCollection services)
        {
            services.AddSingleton<global::{{ MediatorNamespace }}.IMediator, global::{{ MediatorNamespace }}.MediatorImpl>();

            {{~ for handler in Handlers ~}}
            services.AddSingleton<{{ handler.FullName }}, {{ handler.FullName }}>();
            {{~ for handlerInterface in handler.Interfaces ~}}
            services.AddSingleton<{{ handlerInterface.FullName }}>(sp =>
            {
                var concreteHandler = sp.GetRequiredService<{{ handler.FullName }}>();
                {{ if handlerInterface.HasResponse }}
                var pipelineBehaviors = sp.GetServices<global::Mediator.IPipelineBehavior<{{ handlerInterface.RequestType.FullName }}, {{ handlerInterface.ResponseType.FullName }}>>();
                return new {{ handlerInterface.MessageType }}HandlerWrapper<{{ handlerInterface.RequestType.FullName }}, {{ handlerInterface.ResponseType.FullName }}>(
                    concreteHandler,
                    pipelineBehaviors
                );
                {{ else }}
                var pipelineBehaviors = sp.GetServices<global::Mediator.IPipelineBehavior<{{ handlerInterface.RequestType.FullName }}>>();
                return new {{ handlerInterface.MessageType }}HandlerWrapper<{{ handlerInterface.RequestType.FullName }}>(
                    concreteHandler,
                    pipelineBehaviors
                );
                {{ end }}

            });
            {{~ end ~}}
            {{~ end ~}}

            return services;
        }
        
        {{~ for handlerType in HandlerTypes ~}}
        {{ if handlerType.HasResponse }}
        private sealed class {{ handlerType.Name }}HandlerWrapper<T{{ handlerType.Name }}, TResponse> : global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}, TResponse>
            where T{{ handlerType.Name }} : global::Mediator.I{{ handlerType.Name }}<TResponse>
        {
            private readonly global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}, TResponse> _rootHandler;

            public {{ handlerType.Name }}HandlerWrapper(
                global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}, TResponse> concreteHandler,
                global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<T{{ handlerType.Name }}, TResponse>> pipelineBehaviours
            )
            {
                var handler = (global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}, TResponse>)concreteHandler.Handle;

                foreach (var pipeline in pipelineBehaviours.Reverse())
                {
                    var handlerCopy = handler;
                    var pipelineCopy = pipeline;
                    handler = (T{{ handlerType.Name }} message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
                }

                _rootHandler = handler;
            }

            public global::System.Threading.Tasks.ValueTask<TResponse> Handle(T{{ handlerType.Name }} {{ string.downcase handlerType.Name }}, System.Threading.CancellationToken cancellationToken)
            {
                return _rootHandler({{ string.downcase handlerType.Name }}, cancellationToken);
            }
        }
        {{ else }}
        private sealed class {{ handlerType.Name }}HandlerWrapper<T{{ handlerType.Name }}> : global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}>
            where T{{ handlerType.Name }} : global::Mediator.I{{ handlerType.Name }}
        {
            private readonly global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}> _rootHandler;

            public {{ handlerType.Name }}HandlerWrapper(
                global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}> concreteHandler,
                global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<T{{ handlerType.Name }}>> pipelineBehaviours
            )
            {
                var handler = (global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}>)concreteHandler.Handle;

                foreach (var pipeline in pipelineBehaviours.Reverse())
                {
                    var handlerCopy = handler;
                    var pipelineCopy = pipeline;
                    handler = (T{{ handlerType.Name }} message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
                }

                _rootHandler = handler;
            }

            public global::System.Threading.Tasks.ValueTask Handle(T{{ handlerType.Name }} {{ string.downcase handlerType.Name }}, System.Threading.CancellationToken cancellationToken)
            {
                return _rootHandler({{ string.downcase handlerType.Name }}, cancellationToken);
            }
        }
        {{ end }}
        {{~ end ~}}
    }

    /// <summary>
    /// Interface for the mediator pattern implementation.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "1.0.0.0")]
    public interface IMediator
    {
        {{~ for handler in Handlers ~}}
        {{~ for handlerInterface in handler.Interfaces ~}}
        /// <summary>
        /// Message handler for {{ handlerInterface.RequestType.FullName }}.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        {{ handlerInterface.ReturnType }} {{ handlerInterface.MethodName }}({{ handlerInterface.RequestType.FullName }} message, System.Threading.CancellationToken cancellationToken = default);
        {{~ end ~}}
        {{~ end ~}}
    }
    
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "1.0.0.0")]
    internal sealed partial class MediatorImpl : IMediator
    {
        private readonly global::System.IServiceProvider _sp;

        public MediatorImpl(global::System.IServiceProvider sp)
        {
            _sp = sp;
        }

        {{~ for handler in Handlers ~}}
        {{~ for handlerInterface in handler.Interfaces ~}}
        public {{ handlerInterface.ReturnType }} {{ handlerInterface.MethodName }}({{ handlerInterface.RequestType.FullName }} message, System.Threading.CancellationToken cancellationToken = default)
        {
            var sp = _sp;
            var handler = sp.GetRequiredService<{{ handlerInterface.FullName }}>();

            return handler.Handle(message, cancellationToken);
        }
        {{~ end ~}}
        {{~ end ~}}
    }
}
